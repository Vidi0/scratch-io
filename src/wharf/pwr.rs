// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct PatchHeader {
  #[prost(message, optional, tag = "1")]
  pub compression: ::core::option::Option<CompressionSettings>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncHeader {
  #[prost(enumeration = "sync_header::Type", tag = "1")]
  pub r#type: i32,
  #[prost(int64, tag = "16")]
  pub file_index: i64,
}
/// Nested message and enum types in `SyncHeader`.
pub mod sync_header {
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum Type {
    Rsync = 0,
    /// when set, bsdiffTargetIndex must be set
    Bsdiff = 1,
  }
  impl Type {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::Rsync => "RSYNC",
        Self::Bsdiff => "BSDIFF",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "RSYNC" => Some(Self::Rsync),
        "BSDIFF" => Some(Self::Bsdiff),
        _ => None,
      }
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BsdiffHeader {
  #[prost(int64, tag = "1")]
  pub target_index: i64,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SyncOp {
  #[prost(enumeration = "sync_op::Type", tag = "1")]
  pub r#type: i32,
  #[prost(int64, tag = "2")]
  pub file_index: i64,
  #[prost(int64, tag = "3")]
  pub block_index: i64,
  #[prost(int64, tag = "4")]
  pub block_span: i64,
  #[prost(bytes = "vec", tag = "5")]
  pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `SyncOp`.
pub mod sync_op {
  #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
  #[repr(i32)]
  pub enum Type {
    BlockRange = 0,
    Data = 1,
    /// <3 @GranPC & @tomasduda
    HeyYouDidIt = 2049,
  }
  impl Type {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
      match self {
        Self::BlockRange => "BLOCK_RANGE",
        Self::Data => "DATA",
        Self::HeyYouDidIt => "HEY_YOU_DID_IT",
      }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
      match value {
        "BLOCK_RANGE" => Some(Self::BlockRange),
        "DATA" => Some(Self::Data),
        "HEY_YOU_DID_IT" => Some(Self::HeyYouDidIt),
        _ => None,
      }
    }
  }
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SignatureHeader {
  #[prost(message, optional, tag = "1")]
  pub compression: ::core::option::Option<CompressionSettings>,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct BlockHash {
  #[prost(uint32, tag = "1")]
  pub weak_hash: u32,
  #[prost(bytes = "vec", tag = "2")]
  pub strong_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct CompressionSettings {
  #[prost(enumeration = "CompressionAlgorithm", tag = "1")]
  pub algorithm: i32,
  #[prost(int32, tag = "2")]
  pub quality: i32,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ManifestHeader {
  #[prost(message, optional, tag = "1")]
  pub compression: ::core::option::Option<CompressionSettings>,
  #[prost(enumeration = "HashAlgorithm", tag = "2")]
  pub algorithm: i32,
}
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ManifestBlockHash {
  #[prost(bytes = "vec", tag = "1")]
  pub hash: ::prost::alloc::vec::Vec<u8>,
}
/// Wounds files format: header, container, then any
/// number of Wounds
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct WoundsHeader {}
/// Describe a corrupted portion of a file, in [start,end)
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Wound {
  #[prost(int64, tag = "1")]
  pub index: i64,
  #[prost(int64, tag = "2")]
  pub start: i64,
  #[prost(int64, tag = "3")]
  pub end: i64,
  #[prost(enumeration = "WoundKind", tag = "4")]
  pub kind: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CompressionAlgorithm {
  None = 0,
  Brotli = 1,
  Gzip = 2,
  Zstd = 3,
}
impl CompressionAlgorithm {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::None => "NONE",
      Self::Brotli => "BROTLI",
      Self::Gzip => "GZIP",
      Self::Zstd => "ZSTD",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "NONE" => Some(Self::None),
      "BROTLI" => Some(Self::Brotli),
      "GZIP" => Some(Self::Gzip),
      "ZSTD" => Some(Self::Zstd),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HashAlgorithm {
  Shake12832 = 0,
  Crc32c = 1,
}
impl HashAlgorithm {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::Shake12832 => "SHAKE128_32",
      Self::Crc32c => "CRC32C",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "SHAKE128_32" => Some(Self::Shake12832),
      "CRC32C" => Some(Self::Crc32c),
      _ => None,
    }
  }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WoundKind {
  File = 0,
  Symlink = 1,
  Dir = 2,
  /// sent when a file portion has been verified as valid
  ClosedFile = 3,
}
impl WoundKind {
  /// String value of the enum field names used in the ProtoBuf definition.
  ///
  /// The values are not transformed in any way and thus are considered stable
  /// (if the ProtoBuf definition does not change) and safe for programmatic use.
  pub fn as_str_name(&self) -> &'static str {
    match self {
      Self::File => "FILE",
      Self::Symlink => "SYMLINK",
      Self::Dir => "DIR",
      Self::ClosedFile => "CLOSED_FILE",
    }
  }
  /// Creates an enum from field names used in the ProtoBuf definition.
  pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
    match value {
      "FILE" => Some(Self::File),
      "SYMLINK" => Some(Self::Symlink),
      "DIR" => Some(Self::Dir),
      "CLOSED_FILE" => Some(Self::ClosedFile),
      _ => None,
    }
  }
}
